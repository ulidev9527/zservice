package main

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"
	"zserviceapps/packages/zservice"
)

// pb 功能扩展
func main() {

	// 获取启动目录
	projectDir, err := os.Getwd()
	if err != nil {
		zservice.LogErrorf("os.Getwd() failed with \n %s", err)
	}

	// 切换根目录
	if s, e := zservice.GetGomodDir(projectDir); e != nil {
		zservice.LogPanic(e)
	} else {
		projectDir = s
	}

	inputDir := fmt.Sprintf("%s/test/protoc_ex_test", projectDir)
	// 获取传入参数
	if len(os.Args) >= 2 {
		inputDir = os.Args[1]
	}

	// inputDir 不是文件夹，切换到文件夹
	if s, e := os.Stat(inputDir); e != nil {
		zservice.LogPanic(e)
	} else if !s.IsDir() {
		inputDir = filepath.Dir(inputDir)
	}

	// 切换根目录
	if s, e := zservice.GetGomodDir(inputDir); e != nil {
		zservice.LogPanic(e)
	} else {
		projectDir = s
	}

	// 切换到项目目录
	if e := os.Chdir(projectDir); e != nil {
		zservice.LogPanic(e)
	}

	zservice.LogInfo("projectDir", projectDir)

	// 创建临时目录
	tmpDir := filepath.Join(projectDir, "~__protoc_ex_temp_dir_"+time.Now().Format("20060102150405"))
	if err := os.MkdirAll(tmpDir, 0755); err != nil {
		zservice.LogErrorf("os.MkdirAll() failed with \n %s", err)
	}

	// 删除临时目录
	defer os.RemoveAll(tmpDir)

	// 创建 pb 输出目录
	pbOutDir := filepath.Join(tmpDir, "pb")
	if err := os.MkdirAll(pbOutDir, 0755); err != nil {
		zservice.LogErrorf("os.MkdirAll() failed with \n %s", err)
	}

	// 不是绝对路径/获取绝对路径
	if !filepath.IsAbs(inputDir) {

		if s, e := filepath.Abs(inputDir); e != nil {
			zservice.LogError(e)
			os.Exit(0)
		} else {
			inputDir = s
		}
	}

	// 判断路径是否是文件夹，不是则获取到文件夹
	if inputPathStat, err := os.Stat(inputDir); err != nil {
		zservice.LogErrorf("os.Stat() failed with \n %s", err)
	} else if !inputPathStat.IsDir() {
		inputDir = filepath.Dir(inputDir)
	}

	// 解析出所有 proto 文件
	protoFiles := getAllProtoFilesInfo(inputDir)

	if len(protoFiles) == 0 {
		zservice.LogInfo("no file in:", inputDir)
		return
	}

	// 将所有文件拷贝到临时目录
	for _, protoFile := range protoFiles {
		os.WriteFile(filepath.Join(tmpDir, filepath.Base(protoFile.NewPath)), []byte(protoFile.Body), 0644)
	}

	protoFilePaths := []string{}
	for _, protoFile := range protoFiles {
		protoFilePaths = append(protoFilePaths, filepath.Join(tmpDir, filepath.Base(protoFile.NewPath)))
	}
	zservice.LogInfo("projectDir", projectDir)
	zservice.LogInfo("inputPath", inputDir)
	zservice.LogInfo("protoFilePaths", protoFilePaths)

	// 生成相关文件
	runProtocCmd(tmpDir, pbOutDir, protoFilePaths)                 // 生成 pb 文件
	Run_Gen_EConst(pbOutDir)                                       // 生成常量 提前处理，避免解析文件过多
	protoMessageInfos := getProtoMessageInfo(protoFiles, pbOutDir) // 获取 proto 消息信息

	go_output_str := `// Code generated by packages/protoc_ex.run_Gen_Go_PoolMethod DO NOT EDIT.
package pb
import (
	"sync"
	"zserviceapps/packages/zservice"
)
`
	go_output_str = run_Gen_Go_PoolMethod(go_output_str, protoMessageInfos)  // 生成 go 池
	go_output_str = run_Gen_Go_FieldMethod(go_output_str, protoMessageInfos) // 生成 go Set 相关方法
	go_output_str = run_Gen_Go_CloneMethod(go_output_str, protoMessageInfos) // 生成 go Clone 相关方法
	go_output_str = run_Gen_Go_AddMethod(go_output_str, protoMessageInfos)   // 生成 go Add 相关方法

	// 将代码输出到文件
	os.WriteFile(fmt.Sprintf("%s/%s.ex.go", pbOutDir, "ex"), []byte(go_output_str), 0644)

	// 删除输出目录所有的 auto_gen_protoc_ex_开头的 文件
	if files, e := os.ReadDir(inputDir); e != nil {
		zservice.LogErrorf("os.ReadDir() failed with \n %s", e)
	} else {
		for _, file := range files {
			if strings.HasPrefix(file.Name(), "auto_gen_protoc_ex") {
				os.Remove(filepath.Join(inputDir, file.Name()))
			}
		}
	}

	// 将输出目录到文件拷贝到项目目录
	if files, e := os.ReadDir(pbOutDir); e != nil {
		zservice.LogErrorf("os.ReadDir() failed with \n %s", e)
	} else {

		syncFiles := []string{
			filepath.Join(inputDir, "common.proto"),
		}

		for _, file := range files {

			if file.IsDir() {
				continue
			}
			if file.Name() == "Common.cs" || file.Name() == "pb.const.cs" {

				if bt, e := os.ReadFile(filepath.Join(pbOutDir, file.Name())); e != nil {
					zservice.LogErrorf("os.ReadFile() failed with \n %s", e)
					continue
				} else {
					outPath := filepath.Join(inputDir, "csharp", fmt.Sprintf("auto_gen_protoc_ex_%s", file.Name()))
					os.WriteFile(outPath, bt, 0644)
					syncFiles = append(syncFiles, outPath)
				}
			} else if strings.HasSuffix(file.Name(), ".go") {

				if bt, e := os.ReadFile(filepath.Join(pbOutDir, file.Name())); e != nil {
					zservice.LogErrorf("os.ReadFile() failed with \n %s", e)
					continue
				} else {
					os.WriteFile(filepath.Join(inputDir, "golang", fmt.Sprintf("auto_gen_protoc_ex_%s", file.Name())), bt, 0644)
				}
			}

		}

		if bt, e := os.ReadFile(filepath.Join(inputDir, "syncclient.conf")); e != nil {
			if !os.IsNotExist(e) {
				zservice.LogError(e)
			}
		} else {
			lines := strings.SplitSeq(string(bt), "\n")
			for line := range lines {
				line = strings.TrimSpace(line)
				if line == "" || strings.HasPrefix(line, "#") {
					continue
				}
				// 检查路径是否存在
				if fi, err := os.Stat(line); err == nil && fi.IsDir() {
					// 复制 syncFiles 到该路径下
					for _, f := range syncFiles {
						dst := filepath.Join(line, filepath.Base(f))
						if data, err := os.ReadFile(f); err != nil {
							zservice.LogError("read fail:", f, e)
						} else if e := os.WriteFile(dst, data, 0644); e != nil {
							zservice.LogError("write fail:", dst, e)
						} else {
							zservice.LogInfo("copy", strings.TrimPrefix(f, inputDir), dst)
						}
					}
				}
			}
		}

	}

	// grpc 创建变量使用对象池
	// 替换 new(XXX) 为 Get_XXX()
	// if e := Run_Gen_GO_regexp(inputDir); e != nil {
	// 	zservice.LogError(e)
	// }

}
